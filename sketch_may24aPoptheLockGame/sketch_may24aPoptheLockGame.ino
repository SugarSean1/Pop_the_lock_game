#include <Adafruit_CircuitPlayground.h>

float midi[127];
int A_four = 440; // a is 440 hz...

#define LED_COUNT 10

//speach elements
const uint8_t spZERO[]          PROGMEM = {0x69,0xFB,0x59,0xDD,0x51,0xD5,0xD7,0xB5,0x6F,0x0A,0x78,0xC0,0x52,0x01,0x0F,0x50,0xAC,0xF6,0xA8,0x16,0x15,0xF2,0x7B,0xEA,0x19,0x47,0xD0,0x64,0xEB,0xAD,0x76,0xB5,0xEB,0xD1,0x96,0x24,0x6E,0x62,0x6D,0x5B,0x1F,0x0A,0xA7,0xB9,0xC5,0xAB,0xFD,0x1A,0x62,0xF0,0xF0,0xE2,0x6C,0x73,0x1C,0x73,0x52,0x1D,0x19,0x94,0x6F,0xCE,0x7D,0xED,0x6B,0xD9,0x82,0xDC,0x48,0xC7,0x2E,0x71,0x8B,0xBB,0xDF,0xFF,0x1F};
const uint8_t spONE[]           PROGMEM = {0x66,0x4E,0xA8,0x7A,0x8D,0xED,0xC4,0xB5,0xCD,0x89,0xD4,0xBC,0xA2,0xDB,0xD1,0x27,0xBE,0x33,0x4C,0xD9,0x4F,0x9B,0x4D,0x57,0x8A,0x76,0xBE,0xF5,0xA9,0xAA,0x2E,0x4F,0xD5,0xCD,0xB7,0xD9,0x43,0x5B,0x87,0x13,0x4C,0x0D,0xA7,0x75,0xAB,0x7B,0x3E,0xE3,0x19,0x6F,0x7F,0xA7,0xA7,0xF9,0xD0,0x30,0x5B,0x1D,0x9E,0x9A,0x34,0x44,0xBC,0xB6,0x7D,0xFE,0x1F};
const uint8_t spTWO[]           PROGMEM = {0x06,0xB8,0x59,0x34,0x00,0x27,0xD6,0x38,0x60,0x58,0xD3,0x91,0x55,0x2D,0xAA,0x65,0x9D,0x4F,0xD1,0xB8,0x39,0x17,0x67,0xBF,0xC5,0xAE,0x5A,0x1D,0xB5,0x7A,0x06,0xF6,0xA9,0x7D,0x9D,0xD2,0x6C,0x55,0xA5,0x26,0x75,0xC9,0x9B,0xDF,0xFC,0x6E,0x0E,0x63,0x3A,0x34,0x70,0xAF,0x3E,0xFF,0x1F};
const uint8_t spTHREE[]         PROGMEM = {0x0C,0xE8,0x2E,0x94,0x01,0x4D,0xBA,0x4A,0x40,0x03,0x16,0x68,0x69,0x36,0x1C,0xE9,0xBA,0xB8,0xE5,0x39,0x70,0x72,0x84,0xDB,0x51,0xA4,0xA8,0x4E,0xA3,0xC9,0x77,0xB1,0xCA,0xD6,0x52,0xA8,0x71,0xED,0x2A,0x7B,0x4B,0xA6,0xE0,0x37,0xB7,0x5A,0xDD,0x48,0x8E,0x94,0xF1,0x64,0xCE,0x6D,0x19,0x55,0x91,0xBC,0x6E,0xD7,0xAD,0x1E,0xF5,0xAA,0x77,0x7A,0xC6,0x70,0x22,0xCD,0xC7,0xF9,0x89,0xCF,0xFF,0x03};
const uint8_t spFOUR[]          PROGMEM = {0x08,0x68,0x21,0x0D,0x03,0x04,0x28,0xCE,0x92,0x03,0x23,0x4A,0xCA,0xA6,0x1C,0xDA,0xAD,0xB4,0x70,0xED,0x19,0x64,0xB7,0xD3,0x91,0x45,0x51,0x35,0x89,0xEA,0x66,0xDE,0xEA,0xE0,0xAB,0xD3,0x29,0x4F,0x1F,0xFA,0x52,0xF6,0x90,0x52,0x3B,0x25,0x7F,0xDD,0xCB,0x9D,0x72,0x72,0x8C,0x79,0xCB,0x6F,0xFA,0xD2,0x10,0x9E,0xB4,0x2C,0xE1,0x4F,0x25,0x70,0x3A,0xDC,0xBA,0x2F,0x6F,0xC1,0x75,0xCB,0xF2,0xFF};
const uint8_t spFIVE[]          PROGMEM = {0x08,0x68,0x4E,0x9D,0x02,0x1C,0x60,0xC0,0x8C,0x69,0x12,0xB0,0xC0,0x28,0xAB,0x8C,0x9C,0xC0,0x2D,0xBB,0x38,0x79,0x31,0x15,0xA3,0xB6,0xE4,0x16,0xB7,0xDC,0xF5,0x6E,0x57,0xDF,0x54,0x5B,0x85,0xBE,0xD9,0xE3,0x5C,0xC6,0xD6,0x6D,0xB1,0xA5,0xBF,0x99,0x5B,0x3B,0x5A,0x30,0x09,0xAF,0x2F,0xED,0xEC,0x31,0xC4,0x5C,0xBE,0xD6,0x33,0xDD,0xAD,0x88,0x87,0xE2,0xD2,0xF2,0xF4,0xE0,0x16,0x2A,0xB2,0xE3,0x63,0x1F,0xF9,0xF0,0xE7,0xFF,0x01};
const uint8_t spSIX[]           PROGMEM = {0x04,0xF8,0xAD,0x4C,0x02,0x16,0xB0,0x80,0x06,0x56,0x35,0x5D,0xA8,0x2A,0x6D,0xB9,0xCD,0x69,0xBB,0x2B,0x55,0xB5,0x2D,0xB7,0xDB,0xFD,0x9C,0x0D,0xD8,0x32,0x8A,0x7B,0xBC,0x02,0x00,0x03,0x0C,0xB1,0x2E,0x80,0xDF,0xD2,0x35,0x20,0x01,0x0E,0x60,0xE0,0xFF,0x01};
const uint8_t spSEVEN[]         PROGMEM = {0x0C,0xF8,0x5E,0x4C,0x01,0xBF,0x95,0x7B,0xC0,0x02,0x16,0xB0,0xC0,0xC8,0xBA,0x36,0x4D,0xB7,0x27,0x37,0xBB,0xC5,0x29,0xBA,0x71,0x6D,0xB7,0xB5,0xAB,0xA8,0xCE,0xBD,0xD4,0xDE,0xA6,0xB2,0x5A,0xB1,0x34,0x6A,0x1D,0xA7,0x35,0x37,0xE5,0x5A,0xAE,0x6B,0xEE,0xD2,0xB6,0x26,0x4C,0x37,0xF5,0x4D,0xB9,0x9A,0x34,0x39,0xB7,0xC6,0xE1,0x1E,0x81,0xD8,0xA2,0xEC,0xE6,0xC7,0x7F,0xFE,0xFB,0x7F};
const uint8_t spEIGHT[]         PROGMEM = {0x65,0x69,0x89,0xC5,0x73,0x66,0xDF,0xE9,0x8C,0x33,0x0E,0x41,0xC6,0xEA,0x5B,0xEF,0x7A,0xF5,0x33,0x25,0x50,0xE5,0xEA,0x39,0xD7,0xC5,0x6E,0x08,0x14,0xC1,0xDD,0x45,0x64,0x03,0x00,0x80,0x00,0xAE,0x70,0x33,0xC0,0x73,0x33,0x1A,0x10,0x40,0x8F,0x2B,0x14,0xF8,0x7F};
const uint8_t spNINE[]          PROGMEM = {0xE6,0xA8,0x1A,0x35,0x5D,0xD6,0x9A,0x35,0x4B,0x8C,0x4E,0x6B,0x1A,0xD6,0xA6,0x51,0xB2,0xB5,0xEE,0x58,0x9A,0x13,0x4F,0xB5,0x35,0x67,0x68,0x26,0x3D,0x4D,0x97,0x9C,0xBE,0xC9,0x75,0x2F,0x6D,0x7B,0xBB,0x5B,0xDF,0xFA,0x36,0xA7,0xEF,0xBA,0x25,0xDA,0x16,0xDF,0x69,0xAC,0x23,0x05,0x45,0xF9,0xAC,0xB9,0x8F,0xA3,0x97,0x20,0x73,0x9F,0x54,0xCE,0x1E,0x45,0xC2,0xA2,0x4E,0x3E,0xD3,0xD5,0x3D,0xB1,0x79,0x24,0x0D,0xD7,0x48,0x4C,0x6E,0xE1,0x2C,0xDE,0xFF,0x0F};
const uint8_t spTEN[]           PROGMEM = {0x0E,0x38,0x3C,0x2D,0x00,0x5F,0xB6,0x19,0x60,0xA8,0x90,0x93,0x36,0x2B,0xE2,0x99,0xB3,0x4E,0xD9,0x7D,0x89,0x85,0x2F,0xBE,0xD5,0xAD,0x4F,0x3F,0x64,0xAB,0xA4,0x3E,0xBA,0xD3,0x59,0x9A,0x2E,0x75,0xD5,0x39,0x6D,0x6B,0x0A,0x2D,0x3C,0xEC,0xE5,0xDD,0x1F,0xFE,0xB0,0xE7,0xFF,0x03};
const uint8_t spELEVEN[]        PROGMEM = {0xA5,0xEF,0xD6,0x50,0x3B,0x67,0x8F,0xB9,0x3B,0x23,0x49,0x7F,0x33,0x87,0x31,0x0C,0xE9,0x22,0x49,0x7D,0x56,0xDF,0x69,0xAA,0x39,0x6D,0x59,0xDD,0x82,0x56,0x92,0xDA,0xE5,0x74,0x9D,0xA7,0xA6,0xD3,0x9A,0x53,0x37,0x99,0x56,0xA6,0x6F,0x4F,0x59,0x9D,0x7B,0x89,0x2F,0xDD,0xC5,0x28,0xAA,0x15,0x4B,0xA3,0xD6,0xAE,0x8C,0x8A,0xAD,0x54,0x3B,0xA7,0xA9,0x3B,0xB3,0x54,0x5D,0x33,0xE6,0xA6,0x5C,0xCB,0x75,0xCD,0x5E,0xC6,0xDA,0xA4,0xCA,0xB9,0x35,0xAE,0x67,0xB8,0x46,0x40,0xB6,0x28,0xBB,0xF1,0xF6,0xB7,0xB9,0x47,0x20,0xB6,0x28,0xBB,0xFF,0x0F};
const uint8_t spTHIR_[]         PROGMEM = {0x04,0xA8,0xBE,0x5C,0x00,0xDD,0xA5,0x11,0xA0,0xFA,0x72,0x02,0x74,0x97,0xC6,0x01,0x09,0x9C,0xA6,0xAB,0x30,0x0D,0xCE,0x7A,0xEA,0x6A,0x4A,0x39,0x35,0xFB,0xAA,0x8B,0x1B,0xC6,0x76,0xF7,0xAB,0x2E,0x79,0x19,0xCA,0xD5,0xEF,0xCA,0x57,0x08,0x14,0xA1,0xDC,0x45,0x64,0x03,0x00,0xC0,0xFF,0x03};
const uint8_t spTWELVE[]        PROGMEM = {0x09,0x98,0xDA,0x22,0x01,0x37,0x78,0x1A,0x20,0x85,0xD1,0x50,0x3A,0x33,0x11,0x81,0x5D,0x5B,0x95,0xD4,0x44,0x04,0x76,0x9D,0xD5,0xA9,0x3A,0xAB,0xF0,0xA1,0x3E,0xB7,0xBA,0xD5,0xA9,0x2B,0xEB,0xCC,0xA0,0x3E,0xB7,0xBD,0xC3,0x5A,0x3B,0xC8,0x69,0x67,0xBD,0xFB,0xE8,0x67,0xBF,0xCA,0x9D,0xE9,0x74,0x08,0xE7,0xCE,0x77,0x78,0x06,0x89,0x32,0x57,0xD6,0xF1,0xF1,0x8F,0x7D,0xFE,0x1F};
const uint8_t spTWENTY[]        PROGMEM = {0x0A,0xE8,0x4A,0xCD,0x01,0xDB,0xB9,0x33,0xC0,0xA6,0x54,0x0C,0xA4,0x34,0xD9,0xF2,0x0A,0x6C,0xBB,0xB3,0x53,0x0E,0x5D,0xA6,0x25,0x9B,0x6F,0x75,0xCA,0x61,0x52,0xDC,0x74,0x49,0xA9,0x8A,0xC4,0x76,0x4D,0xD7,0xB1,0x76,0xC0,0x55,0xA6,0x65,0xD8,0x26,0x99,0x5C,0x56,0xAD,0xB9,0x25,0x23,0xD5,0x7C,0x32,0x96,0xE9,0x9B,0x20,0x7D,0xCB,0x3C,0xFA,0x55,0xAE,0x99,0x1A,0x30,0xFC,0x4B,0x3C,0xFF,0x1F};

const uint8_t sp_TEEN[]         PROGMEM = {0x09,0x58,0x2A,0x25,0x00,0xCB,0x9F,0x95,0x6C,0x14,0x21,0x89,0xA9,0x78,0xB3,0x5B,0xEC,0xBA,0xB5,0x23,0x13,0x46,0x97,0x99,0x3E,0xD6,0xB9,0x2E,0x79,0xC9,0x5B,0xD8,0x47,0x41,0x53,0x1F,0xC7,0xE1,0x9C,0x85,0x54,0x22,0xEC,0xFA,0xDB,0xDD,0x23,0x93,0x49,0xB8,0xE6,0x78,0xFF,0x3F};
const uint8_t spIS[]            PROGMEM = {0xAD,0xED,0xD5,0x58,0xA4,0x9E,0xCE,0x76,0xF5,0xDD,0xAB,0x29,0xF5,0xD2,0xDD,0xEF,0x7E,0x0C,0xC3,0xA9,0x06,0xFA,0xD3,0x32,0x0F,0x6E,0x94,0x22,0x8F,0xF3,0x92,0xF6,0x05,0x43,0xCC,0x74,0x77,0x3E,0xC3,0xF5,0x95,0x98,0xA9,0xBA,0x8B,0x8F,0x00,0x7E,0x73,0xE5,0x00,0x05,0x28,0xF0,0xFF};
const uint8_t spPOINT[]         PROGMEM = {0x06,0xA8,0xCC,0x4B,0x03,0x2D,0xF3,0x69,0x2B,0x8C,0x1A,0xAF,0x2C,0x98,0xE9,0x28,0x4A,0xB3,0xF3,0x53,0xC6,0x90,0x9E,0xC1,0x6D,0x76,0x77,0xE6,0x9C,0x5D,0xD3,0x75,0xF1,0x58,0x5B,0x75,0x76,0xB7,0x4F,0xE3,0xE8,0xCE,0x31,0x3A,0x17,0xB6,0xB3,0x45,0x96,0xF4,0xAA,0x6D,0x4F,0x75,0x76,0xA3,0x94,0x66,0x6E,0x10,0x28,0x42,0xB9,0x8B,0xC8,0x06,0x50,0xC0,0x32,0x11,0x0A,0x58,0x76,0x87,0x01,0x3D,0xB5,0xFE,0x3F};
const uint8_t spREADY[]         PROGMEM = {0x6A,0xB4,0xD9,0x25,0x4A,0xE5,0xDB,0xD9,0x8D,0xB1,0xB2,0x45,0x9A,0xF6,0xD8,0x9F,0xAE,0x26,0xD7,0x30,0xED,0x72,0xDA,0x9E,0xCD,0x9C,0x6D,0xC9,0x6D,0x76,0xED,0xFA,0xE1,0x93,0x8D,0xAD,0x51,0x1F,0xC7,0xD8,0x13,0x8B,0x5A,0x3F,0x99,0x4B,0x39,0x7A,0x13,0xE2,0xE8,0x3B,0xF5,0xCA,0x77,0x7E,0xC2,0xDB,0x2B,0x8A,0xC7,0xD6,0xFA,0x7F,};
  


int startLights = 1;

int targetLed;
int ledRunner;
int ledRunnerSpeed = 500;
int ledRunnerSpeedMin = 50;
int direction = 1;
bool gameActive = false;
int scoreMeter = 3;
int currentScore = 0;
int speechPhrase;

const int startingLevel = 1;
int currentLevel;
const int maxLevel = 10;

volatile bool playerFlag = false;
volatile bool startFlag = false;
volatile bool hardFlag = false;
bool sucessSound = true;

const int buttonRight = 4; 
const int buttonLeft = 5; 


int WIN_SOUND[][2] = {
    {76, 30},
      {127, 30},//rest
    {60, 30},
      {127, 30},//rest
    {65, 30},
      {127, 30},//rest
    {69, 30},
      {127, 30},//rest
    {60, 30},
    {65, 30},
      {127, 50},//rest
    {69, 80},
      {127, 50},//rest

    {76, 30},
      {127, 30},//rest
    {60, 30},
      {127, 30},//rest
    {65, 30},
      {127, 30},//rest
    {69, 30},
      {127, 30},//rest
    {60, 30},
    {65, 30},
      {127, 50},//rest
    {69, 80},
      {127, 50},//rest
};

int LOSE[][2] = {
    /*{70, 50},
    {69, 50},
    {68, 50},
      {127, 30},//rest*/
 //   {68, 52},
    {67, 52},
    {66, 52},
      {127, 60},//rest
   // {66, 55},
    {65, 55},
    {64, 55},
      {127, 120},//rest
    {60, 120},
};

int START_SOUND[][2] = {
    {55, 200},
          {127, 125},//rest
    {55, 200},
          {127, 125},//rest
    {72, 200},
      {127, 125},//rest
};


void setup() {
    CircuitPlayground.begin();
    Serial.begin(9600);
    generateMIDI();
    attachInterrupt(digitalPinToInterrupt (buttonRight), player , RISING);
    attachInterrupt(digitalPinToInterrupt (buttonLeft), start , RISING);
    attachInterrupt(digitalPinToInterrupt (7), hard , CHANGE);
    CircuitPlayground.speaker.set(225);
    randomSeed(analogRead(0));
}

void loop() {
  if (gameActive == true){    
    updateGameState();
  }
  //incase the player presses the player flag button while the game is idling, this prevents an incorrect button flag when the game starts
  else if((playerFlag == true) && (gameActive == false)){
    playerFlag = false;
  }
  else if (hardFlag == true){
    delay (50);
    ledRunnerSpeed = 200;
    ledRunnerSpeedMin = 30;
    CircuitPlayground.playTone(midi[50], 100);
    CircuitPlayground.playTone(midi[55], 150);
    hardFlag = false;
  }
  // During the start sequince, the gameActive will change to true, preventing this from triggering until the game ends.
  else if ((startFlag == true) && (gameActive == false)) {
    delay (20);
    startFlag = false;
    Serial.println("Game is starting");
    startGame();
  }
  else{
  rainbow (4,LED_COUNT);
  //Serial.println("Idle running");  
  }
}

void startGame(){
   CircuitPlayground.clearPixels(); 
   for(int i = 0; i < sizeof(START_SOUND) / sizeof(START_SOUND[0]); i++) // Calculate how many rows are in the array using: sizeof(song) / sizeof(song[0])
   {
      CircuitPlayground.playTone(midi[START_SOUND[i][0]], START_SOUND[i][1]);

        switch(startLights){
          case 1:
            for(int i = 0; i < LED_COUNT; i++){
            CircuitPlayground.setPixelColor(i, 225 , 0 , 0);
            }
            break;
          case 2: 
            for(int i = 0; i < LED_COUNT; i++){
            CircuitPlayground.setPixelColor(i, 255 , 225 , 0);
            }
            break;
          case 3: 
            for(int i = 0; i < LED_COUNT; i++){
            CircuitPlayground.setPixelColor(i, 0 , 255 , 0);
            }
            break;
          default:
            break;
          }

    startLights++;
    }    

   CircuitPlayground.clearPixels(); 
   delay (500);
  
    ledRunner = 0; 
    CircuitPlayground.setPixelColor(ledRunner, 0 , 0 , 255);

    targetLed = 8;
    CircuitPlayground.setPixelColor(targetLed, 255 , 255 , 255);
    currentLevel = 1;

    gameActive = true;

}

void updateGameState(){
   CircuitPlayground.setPixelColor(ledRunner, 0 , 0 , 0);  
   ledRunner = (ledRunner + direction) % LED_COUNT;

    if (targetLed == ledRunner){
      scoreMeter--;
    }

   if(ledRunner < 0) {
      ledRunner += LED_COUNT;
    }
    else if(ledRunner> 9) {
      ledRunner -= (LED_COUNT+1); 
    }
  
    switch(currentLevel){
      case 1:
      
         if(ledRunner == targetLed){
          CircuitPlayground.setPixelColor(ledRunner, 100 , 100 , 255);}
        else{
          CircuitPlayground.setPixelColor(ledRunner, 0 , 0 , 255);}

       break;
      case 2:
      
        if(ledRunner == targetLed){
            CircuitPlayground.setPixelColor(ledRunner, 100 , 125 , 255);}
        else{
           CircuitPlayground.setPixelColor(ledRunner, 0 , 125 , 225);}

       break;
     case 3:

        if(ledRunner == targetLed){
           CircuitPlayground.setPixelColor(ledRunner, 100 , 225 , 100);}
        else{
          CircuitPlayground.setPixelColor(ledRunner, 0 , 255 , 0);}

       break;
     case 4:

          if(ledRunner == targetLed){
           CircuitPlayground.setPixelColor(ledRunner, 125 , 225 , 100);}
          else{
           CircuitPlayground.setPixelColor(ledRunner, 125 , 255 , 0);}

        break;
      case 5:

          if(ledRunner == targetLed){
           CircuitPlayground.setPixelColor(ledRunner, 225 , 225 , 100);}
          else{
           CircuitPlayground.setPixelColor(ledRunner, 255 , 225 , 0);}

       break;
      case 6:

          if(ledRunner == targetLed){
           CircuitPlayground.setPixelColor(ledRunner, 225 , 125 , 100);}
          else{
           CircuitPlayground.setPixelColor(ledRunner, 255 , 125 , 0);}

       break;  
      case 7:

          if(ledRunner == targetLed){
           CircuitPlayground.setPixelColor(ledRunner, 225 , 100 , 100);}
          else{
           CircuitPlayground.setPixelColor(ledRunner, 255 , 0 , 0);}

        break;
      case 8:

          if(ledRunner == targetLed){
           CircuitPlayground.setPixelColor(ledRunner, 225 , 100 , 125);}
          else{
           CircuitPlayground.setPixelColor(ledRunner, 255 , 0 , 125);}


       break;
      case 9:

          if(ledRunner == targetLed){
           CircuitPlayground.setPixelColor(ledRunner, 255 , 100 , 255);}
          else{
           CircuitPlayground.setPixelColor(ledRunner, 255 , 0 , 225);}

       break;
      case 10:
      
          if(ledRunner == targetLed){
           CircuitPlayground.setPixelColor(ledRunner, 100 , 100 , 100);}
          else{
           CircuitPlayground.setPixelColor(ledRunner, 255 , 225 , 225);}

       break;
      default:
       break;
    }
   

    float var = static_cast<float>(currentLevel)/maxLevel; // static_cast<float> is with help from chat GBT to figure out why I was not getting a float value from dividing two intigers. which I know now was becasue the divsion of two integers truncates the float aspect. 
    int speed = ledRunnerSpeed - (ledRunnerSpeed-ledRunnerSpeedMin)*(var);
    delay (speed);

    if (playerFlag){
        delay (90);
        playerFlag = false;
      if (ledRunner == targetLed){
        handleSuccess();  
      }
      else{
      lose();  
      }
    }
    if ((direction == -1)&&(ledRunner == targetLed-1)){
      CircuitPlayground.setPixelColor(targetLed, 255 , 255 , 255);
    }
    else if ((direction == 1) && (ledRunner == targetLed+1)){
      CircuitPlayground.setPixelColor(targetLed, 255 , 255 , 255);
    }
    else if ((ledRunner == 9) && (targetLed == 0 )){
      CircuitPlayground.setPixelColor(targetLed, 255 , 255 , 255);
    }
}

void handleSuccess (){
    if (sucessSound==true){
      CircuitPlayground.playTone(midi[55], 100);
      sucessSound = !sucessSound;
    }
    else if (sucessSound==false){
      CircuitPlayground.playTone(midi[65], 100);
      sucessSound = !sucessSound;
    }

    CircuitPlayground.clearPixels();

    if (scoreMeter <= 0){
      scoreMeter = 3;
    }
    else{
      currentScore = currentScore + scoreMeter;
      scoreMeter = 3;
      Serial.print("Score: ");
      Serial.println(currentScore);
      Serial.println("");
    }

    if (currentLevel < maxLevel){
      targetLed = random(9);
      direction *= -1;
      currentLevel++;
      Serial.print("Current Level: ");
      Serial.println(currentLevel);
      Serial.println("");
      CircuitPlayground.setPixelColor(targetLed, 255 , 255 , 255);  
    }
    else{
      winGame();
    }
}

void lose(){
    CircuitPlayground.clearPixels();
     for(int i = 0; i < sizeof(LOSE) / sizeof(LOSE[0]); i++){
        CircuitPlayground.playTone(midi[LOSE[i][0]], LOSE[i][1]);
      }
    
    CircuitPlayground.setPixelColor(targetLed, 255 , 255 , 255);  
    
    CircuitPlayground.setPixelColor(ledRunner, 255 , 0 , 0);
      delay(400);
    CircuitPlayground.setPixelColor(ledRunner, 0,0,0);
      delay(400);
    CircuitPlayground.setPixelColor(ledRunner, 255 , 0 , 0);
      delay(400);
    CircuitPlayground.setPixelColor(ledRunner, 0,0,0);
      delay(400);
    CircuitPlayground.setPixelColor(ledRunner, 255 , 0 , 0);
      delay(400);
    CircuitPlayground.clearPixels();
    speech();    

    reset();
}

void winGame(){
    
    gameActive = false;
    
    for(int i = 0; i < sizeof(WIN_SOUND) / sizeof(WIN_SOUND[0]); i++){
      CircuitPlayground.playTone(midi[WIN_SOUND[i][0]], WIN_SOUND[i][1]);
         int ledNum = random (0,9);
          CircuitPlayground.setPixelColor( ledNum, 255 , 255 , 255);
          delay (25);
          CircuitPlayground.setPixelColor( ledNum, 0 , 0 , 0);
          delay (25);  
        }

    CircuitPlayground.clearPixels();
        speech ();   
    Serial.println(" YOU WIN! ");
    Serial.println("Final Score: ");
    Serial.print(currentScore);
    reset (); // change all values to starting conditions
}


void reset (){
  startLights = 1;
  playerFlag = false;
  currentLevel = 1;
  startFlag = false;
  gameActive = false;
  currentScore = 0;
  scoreMeter = 3; 
  direction = 1; 
  ledRunnerSpeedMin = 50;
  ledRunnerSpeed = 500;
  CircuitPlayground.speaker.set(225);
}

void rainbow (int currentSpeed, int stripLen) {

  // Make an offset based on the current millisecond count scaled by the current speed.

  uint32_t offset = millis() / currentSpeed;

  // Loop through each pixel and set it to an incremental color wheel value.

  for(int i=0; i<10; ++i) {

    CircuitPlayground.setPixelColor(i, CircuitPlayground.colorWheel(((i * 256 / stripLen) + offset) & 255));
   
    if(startFlag == true){
      break;
    }
  }
}

void speech (){

      CircuitPlayground.speaker.say(spPOINT);
	    CircuitPlayground.speaker.say(spIS);

    switch(currentScore){
      case 0:
            	CircuitPlayground.speaker.say(spZERO);
          break;
      case 1:
      	      CircuitPlayground.speaker.say(spONE);
         break;
      case 2:
      	      CircuitPlayground.speaker.say(spTWO);
          break;
      case 3:
      	      CircuitPlayground.speaker.say(spTHREE);
          break;
      case 4:
      	      CircuitPlayground.speaker.say(spFOUR);
          break;
      case 5:
      	      CircuitPlayground.speaker.say(spFIVE);
          break;
      case 6:
      	      CircuitPlayground.speaker.say(spSIX);
          break;
      case 7:
      	      CircuitPlayground.speaker.say(spSEVEN);
          break;
      case 8:
	      CircuitPlayground.speaker.say(spEIGHT);      
          break;
      case 9:
      	      CircuitPlayground.speaker.say(spNINE);
          break;
      case 10:
      	      CircuitPlayground.speaker.say(spTEN);
          break;
      case 11:
            	CircuitPlayground.speaker.say(spELEVEN);
          break;
      case 12:
            	CircuitPlayground.speaker.say(spTWELVE);
          break;
      case 13:
            	CircuitPlayground.speaker.say(spTHIR_);
              CircuitPlayground.speaker.say(sp_TEEN);

          break;
      case 14:
            	CircuitPlayground.speaker.say(spFOUR);
              CircuitPlayground.speaker.say(sp_TEEN);
          break;
      case 15:
            	CircuitPlayground.speaker.say(spFOUR);
              CircuitPlayground.speaker.say(sp_TEEN);
          break;
      case 16:
            	CircuitPlayground.speaker.say(spSIX);
              CircuitPlayground.speaker.say(sp_TEEN);
          break;
      case 17:
            	CircuitPlayground.speaker.say(spSEVEN);
              CircuitPlayground.speaker.say(sp_TEEN);
          break;
      case 18:
            	CircuitPlayground.speaker.say(spEIGHT);
              CircuitPlayground.speaker.say(sp_TEEN);
          break;
      case 19:
            	CircuitPlayground.speaker.say(spNINE);
              CircuitPlayground.speaker.say(sp_TEEN);
          break;
      case 20:
            	CircuitPlayground.speaker.say(spTWENTY);
          break;
      default:
          break;
    }
  }    

void player(){
  playerFlag = true;
}

void hard(){
  if (gameActive == false){
      hardFlag = true;    
  }
  else
  hardFlag = false;
}

void start(){
  if (gameActive){
      playerFlag = true;    
  }
  else
  startFlag = true; 
}

void generateMIDI(){
  for (int x = 0; x < 127; ++x)
  {
    midi[x] = (A_four / 32.0) * pow(2.0, ((x - 9.0) / 12.0));
    //Serial.println(midi[x]);
  }
}